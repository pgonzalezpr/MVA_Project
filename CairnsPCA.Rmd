---
title: 'Group 1: Multivariate analysis of australian climate data'
author: Andrea Iglesias Munilla, Kathryn Weissman, Diana Galindo Gonzalez, Mateo Jacome
  Gonzalez y Pedro Gonzalez Prado
output:
  html_document:
    self_contained: false
---

## Data imputation


```{r, ini, message=FALSE, warning=FALSE, results='hide'}

# CLEARING ENVIRONMENT #
#rm(list=ls(all=TRUE))
#PREPARE WORK DIRECTORY 
#current_path <- getActiveDocumentContext()$path 
#setwd(dirname(current_path ))

#INSTALL & LOAD LIBRARIES
# Required packages
pkgs<-c("corrplot","DT", "dplyr","FactoMineR","factoextra", "ggplot2", "grid", "gridExtra", "lubridate", "mice", "sm","summarytools", "VIM", "visdat")

# Non-installed packages
inspkgs<-pkgs[!pkgs %in% installed.packages()]
for(libs in inspkgs) install.packages(libs, repos = "http://cran.us.r-project.org")

# Loading required
sapply(pkgs,require,character=TRUE)

df <- read.csv("df_Cairns.csv",sep=",",stringsAsFactors = T)
df$Date <- as.Date(df$Date)
```
###  CAIRNS

```{r, vars, message=FALSE, warning=FALSE}


#SUMMARIZE DATA BY COLUMN
dfSummary(df, method = 'render')
```

```{r,  message=FALSE, warning=FALSE, results='hide'}
#HISTOGRAMS AND CORRELATION PLOTS FOR COMPLETE NUMERIC OBSERVATIONS
nums <- unlist(lapply(df, is.numeric)) 
numrain_data<-df[ , nums]
numrain_data<-subset(numrain_data,complete.cases(numrain_data))
a<-names(numrain_data)
a<-as.list(a)

fun02<-function(i){index=grep(i,names(numrain_data))
bw <- nclass.Sturges(numrain_data[,index]) # Freedman-Diaconis
nm=paste0(i)
assign(paste("g",i,sep=""),
       ggplot(numrain_data, aes(numrain_data[,index])) +  
         geom_histogram(bins = bw,aes(y=..density..), fill="#de2d26") +
         geom_density(alpha=.35, fill="#08519c",color = NA)  +
         geom_vline (aes(xintercept=median(numrain_data[,index])),color="#08519c", size=1) + 
         labs(title=nm, x=NULL, y="UPAS")) +
  theme(plot.title = element_text(size = rel(0.7),face ="bold",hjust = 0.5),
        axis.title.y = element_text(size = rel(0.4)),
        axis.text = element_text(size = rel(0.4)))
}
Histos<-lapply(a[-1],fun02)
do.call(grid.arrange, Histos)

cor_matrix = cor(numrain_data[,c(4:19)]) #starting from column 4: MinTemp
corrplot(cor_matrix, method = 'number',number.cex= 9/ncol(cor_matrix), tl.cex = .8,tl.col= "darkgray") # colorful number
```
## DETECT MISSING DATA

```{r,  message=FALSE, warning=FALSE, results='hide'}
#Missing Data from WIND already imputed in other .RMd file.

#Detecting missing data by row
mis_ind = rowSums(is.na(df))
m1<-which(mis_ind>0)
df_NAs <- df[m1,]
table(mis_ind)

# Detecting Missing Values by Column as count
mis_col <- colSums(is.na(df))
mis_col


#Detecting Missing Dates from date range
date_range <- seq(min(df$Date), max(df$Date), by = 1) 
missing_dates <- data.frame(date = date_range[!date_range %in% df$Date]) 
###It appears we are missing April 2011, December 2012, and February 2013

# Missing Data Graphs
vis_miss(df)

aggr(df, col=c('grey','#252525'), numbers=TRUE, sortVars=TRUE, labels=names(df), 
     cex.axis=.5, gap=1, ylab=c("Missing data"," "),border=NA)
```

Very few numerical data are missing, Evaporation is not strongly correlated with any other numeric variable. Cloud3pm is negatively correlated with Sunshine and positively correlated with Cloud9am and Humidity3pm. Sunshine is negatively correlated with the Humidity and Cloud measurements.


```{r,  message=FALSE, warning=FALSE, results='hide'}
#CHECK NAs FOR EVAPORATION
#create variable to identify rows that are missing Evaporation
na_Evaporation <- which(is.na(df_NAs$Evaporation))
#create dataframe to check summary statistics of observations missing Evaporation
df_NA_Evap<- df_NAs[na_Evaporation,]
summary(df_NA_Evap)

#Plotting histograms side by side for rainfall in full data set vs on days when
#Evaporation is NA
c1 <- rgb(173,216,230, max=255, alpha=80, names = "lt.blue") #create transparent color
c2 <- rgb(255,192,203, max=255, alpha=80, names = "lt.pink") # create transparent color

rain_full <- df$Rainfall
rain_evap <- df_NA_Evap$Rainfall
b <- min(c(rain_full,rain_evap), na.rm=TRUE) # Set the minimum for the breakpoints
e <- max(c(rain_full,rain_evap), na.rm=TRUE) # Set the maximum for the breakpoints
ax <- pretty(b:e, n=20) # Make a neat vector for the breakpoints
hgRainfall <- hist(rain_full, breaks = ax, plot = FALSE) # Save first histogram data
hgRainfall_Evap <- hist(rain_evap, breaks = ax, plot = FALSE) # Save 2nd histogram data
plot(hgRainfall, col=c1, freq=FALSE, main="Side by Side Histograms for Rainfall",
     xlab="Rainfall per Day (mm)",) # Plot 1st histogram using a transparent color
plot(hgRainfall_Evap, col=c2, add=TRUE,freq=FALSE) # Add 2nd histogram using different color
legend("topright", c("All Days", "Days with Evaporation NA"), fill=c(c1,c2))

#Plotting histograms side by side for Humidity3pm in full data set vs on days when
#Evaporation is NA

humid3_full <- df$Humidity3pm
humid3_evap <- df_NA_Evap$Humidity3pm
b <- min(c(humid3_full,humid3_evap), na.rm=TRUE) # Set the minimum for the breakpoints
e <- max(c(humid3_full,humid3_evap), na.rm=TRUE) # Set the maximum for the breakpoints
ax <- pretty(b:e, n=20) # Make a neat vector for the breakpoints
hgHumid3 <- hist(humid3_full, breaks = ax, plot = FALSE) # Save first histogram data
hgHumid3_Evap <- hist(humid3_evap, breaks = ax, plot = FALSE) # Save 2nd histogram data
plot(hgHumid3_Evap, col=c2, freq=FALSE, main="Side by Side Histograms for Humidity at 3pm",
     xlab="Relative Humidity Percentage at 3pm",) # Plot 1st histogram using a transparent color
plot(hgHumid3, col=c1, add=TRUE,freq=FALSE) # Add 2nd histogram using different color
legend("topleft", c("All Days", "Days with Evaporation NA"), fill=c(c1,c2))

#Plotting histograms side by side for Humidity9am in full data set vs on days when
#Evaporation is NA

humid9_full <- df$Humidity9am
humid9_evap <- df_NA_Evap$Humidity9am
b <- min(c(humid9_full,humid9_evap), na.rm=TRUE) # Set the minimum for the breakpoints
e <- max(c(humid9_full,humid9_evap), na.rm=TRUE) # Set the maximum for the breakpoints
ax <- pretty(b:e, n=20) # Make a neat vector for the breakpoints
hgHumid9 <- hist(humid9_full, breaks = ax, plot = FALSE) # Save first histogram data
hgHumid9_Evap <- hist(humid9_evap, breaks = ax, plot = FALSE) # Save 2nd histogram data
plot(hgHumid9_Evap, col=c2, freq=FALSE, main="Side by Side Histograms for Humidity at 9am",
     xlab="Relative Humidity Percentage at 9am",) # Plot 1st histogram using a transparent color
plot(hgHumid9, col=c1, add=TRUE,freq=FALSE) # Add 2nd histogram using different color
legend("topleft", c("All Days", "Days with Evaporation NA"), fill=c(c1,c2))


###The missing values for Evaporation are clearly not random. They tend to occur on days
###with higher than average rainfall and humidity. In theory, the higher the relative humidity,
###the lower the evaporation should be.
```


```{r,  message=FALSE, warning=FALSE, results='hide'}
#CHECK NAs FOR SUNSHINE
#create variable to identify rows that are missing Sunshine
na_Sunshine <- which(is.na(df_NAs$Sunshine))
#check rows of observations missing Sunshine
df_NAs[na_Sunshine,]

###The missing values for Sunshine do not appear random. All days are in Summer, 
###and on days with rainfall, high cloud cover, or both.

#CHECK NAs FOR WIND GUST SPEED
#create variable to identify rows that are missing WindGustSpeed
na_GustSpeed <- which(is.na(df_NAs$WindGustSpeed))
#check rows of observations missing WindGustSpeed
df_NAs[na_GustSpeed,]

#Plotting histograms side by side for WindSpeed3pm in full data set vs on days when
#WindGustSpeed is NA

Speed3pm_full <- df$WindSpeed3pm
Speed3pm_wgNA <- df_NAs[na_GustSpeed,]$WindSpeed3pm
b <- min(c(Speed3pm_full,Speed3pm_wgNA), na.rm=TRUE) # Set the minimum for the breakpoints
e <- max(c(Speed3pm_full,Speed3pm_wgNA), na.rm=TRUE) # Set the maximum for the breakpoints
ax <- pretty(b:e, n=20) # Make a neat vector for the breakpoints
hgSpeed3pm <- hist(Speed3pm_full, breaks = ax, plot = FALSE) # Save first histogram data
hgSpeed3pm_wgNA <- hist(Speed3pm_wgNA, breaks = ax, plot = FALSE) # Save 2nd histogram data
plot(hgSpeed3pm_wgNA, col=c2, freq=FALSE, main="Side by Side Histograms for Wind Speed at 3pm",
     xlab="Wind Speed at 3pm",) # Plot 1st histogram using a transparent color
plot(hgSpeed3pm, col=c1, add=TRUE,freq=FALSE) # Add 2nd histogram using different color
legend("topleft", c("All Days", "Days with WindGustSpeed NA"), fill=c(c1,c2))
```


WindGustSpeed is potentially missing randomly, however WindGustDir is only missing when WindGustSpeed is missing.


```{r,  message=FALSE, warning=FALSE, results='hide'}
#CHECK NAs FOR CLOUD
#create variable to identify rows that are missing Cloud9am
na_Cloud9 <- which(is.na(df_NAs$Cloud9am))
#check rows of observations missing Cloud9am
df_NAs[na_Cloud9,]

#create variable to identify rows that are missing Cloud3pm
na_Cloud3 <- which(is.na(df_NAs$Cloud3pm))
#check rows of observations missing Cloud3pm
df_NAs[na_Cloud3,]

###Cloud data is potentially missing randomly. The days that have data missing at 9am
###have data available at 3pm and vice versa.

#IMPUTE MISSING VALUES

###'calm' added to wind levels in other .csv

##create variable to identify rows that are missing wind direction at 9am
#na_WindDir9am <- which(is.na(df$WindDir9am))
##check summary of wind speed at 9am for rows that are missing wind direction at 9am
#summary(df[na_WindDir9am,]$WindSpeed9am)
#### All values of WindDir9am can be imputed to 'Calm'
##imputation using row identifier
#df$WindDir9am[na_WindDir9am] <- 'Calm'

##create variable to identify rows that are missing wind direction at 3pm
#na_WindDir3pm <- which(is.na(df$WindDir3pm))
##check summary of wind speed at 3pm for rows that are missing wind direction at 3pm
#summary(df[na_WindDir3pm,]$WindSpeed3pm)
#### All values of WindDir3pm can be imputed to 'Calm'
##imputation using row identifier
#df$WindDir3pm[na_WindDir3pm] <- 'Calm'

# IMPUTATION BY MICE

md.pattern(df)

tempData <- mice(df[,c("Month","MinTemp","MaxTemp","Rainfall","Evaporation",
                       "Sunshine","WindGustDir","WindGustSpeed","WindDir9am",
                       "WindDir3pm","WindSpeed9am","WindSpeed3pm","Humidity9am",
                       "Humidity3pm","Pressure9am","Pressure3pm","Cloud9am",
                       "Cloud3pm","Temp9am","Temp3pm")],m=3,set.seed(2))
tempData$meth
summary(tempData)
completedData <- complete(tempData,1)
xyplot(tempData,Evaporation ~ Humidity9am+Humidity3pm,pch=18,cex=1)
xyplot(tempData,Evaporation ~ Rainfall,pch=18,cex=1)
densityplot(tempData)

summary(completedData)


#Compare density plots of original data with completed data
plot(density(df$Evaporation, na.rm=TRUE), col='red')
lines(density(completedData$Evaporation), col='blue')

plot(density(df$WindGustSpeed, na.rm=TRUE), col='red')
lines(density(completedData$WindGustSpeed), col='blue')

plot(density(df$Sunshine, na.rm=TRUE), col='red')
lines(density(completedData$Sunshine), col='blue')

plot(density(df$Cloud9am, na.rm=TRUE), col='red')
lines(density(completedData$Cloud9am), col='blue')

plot(density(df$Cloud3pm, na.rm=TRUE), col='red')
lines(density(completedData$Cloud3pm), col='blue')

plot(density(df$Rainfall, na.rm=TRUE), col='red')
lines(density(completedData$Rainfall), col='blue')

###Density plots of imputed variables match density plots of original variables
###with NA's removed.


#Replace original data with completed data from MICE
df[,c("Month","MinTemp","MaxTemp","Rainfall","Evaporation",
      "Sunshine","WindGustDir","WindGustSpeed","WindDir9am",
      "WindDir3pm","WindSpeed9am","WindSpeed3pm","Humidity9am",
      "Humidity3pm","Pressure9am","Pressure3pm","Cloud9am",
      "Cloud3pm","Temp9am","Temp3pm")] <- completedData

#IMPUTE RAINTODAY & RAINTOMORROW

#Fill RainToday & RainTomorrow NAs with appropriate values based on Rainfall.
#identify rows which are missing RainToday & Rainfall > .01 and impute "Yes"
na_RainYes <- which(is.na(df$RainToday) & (df$Rainfall > .01))
df[na_RainYes,]$RainToday <- "Yes"
#identify dates from imputed values
dates_RainYes <- df[na_RainYes,]$Date
#identify dates before imputed values
dates_RainTomYes <- df[na_RainYes,]$Date - 1 
#identify rows for day before imputed Rain and impute "Yes"
na_RainTomYes <- which(df$Date == dates_RainTomYes)
df[na_RainTomYes,]$RainTomorrow <- "Yes"

summary(df)

#All NAs are filled, write new .csv to use for imputing time series.
#write.csv(df,'df_Cairns_MICE.csv', row.names = FALSE)

#https://www.earthdatascience.org/courses/earth-analytics/time-series-data/summarize-time-series-by-month-in-r/
# plot rainfall as time series
df %>%
  ggplot(aes(x = Date, y = Rainfall)) +
  geom_point(color = "darkorchid4") +
  labs(title = "Rainfall",
       y = "Daily rainfall (mm)",
       x = "Date") + theme_bw(base_size = 15)
```

### PCA, MCA, MFA

#### PCA

The principal components of the data set are calculated.
```{r, message=FALSE}
#Regular components
nums <- unlist(lapply(df, is.numeric))  
df_pca<-df[ , nums]
pc1<-PCA(df_pca, scale.unit=TRUE,ncp=15,graph=FALSE)
```

The eigenvalues, the percentage of variance retained for each component and the sedimentation plot (_Scree Plot_) are then generated. There are several "cubits" on the bar graph, between components 2 and 3, between components 4 and 5, and between 6 and 7.

```{r, message=FALSE}
fviz_eig(pc1,addlabels = TRUE,xlab="Components",ylab="% explained variances by PCA")
datatable(round(pc1$eig,3), options = list(pageLength = 10))
```

Representation of variables by component

```{r, message=FALSE}
corrplot(pc1$var$cos2,is.corr=FALSE,number.cex = 0.5,tl.col="gray31",tl.cex=0.5,
	   cl.ratio=0.30,cl.cex=0.35, cl.align="c",mar=c(0,1,1,0),title="Quality of representation(variables)",cex.main=0.7)

corrplot(pc1$var$cor,cex.main=0.7,method = c("square"),number.cex = 0.5,tl.cex=0.7,tl.col="gray31",cl.align="c",tl.offset = 0.1)
```

Correlation circle of the first factorial plane

```{r, message=FALSE}

fviz_pca_var(pc1,col.var="cos2",repel=TRUE,labelsize = 3,gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), legend.title= paste0("Cos2",'\n',"(var)"))
#Individuals graph
fviz_pca_biplot(pc1,axes=c(1,2), ggtheme = theme_minimal(),labelsize=3,col.ind = "gray67",geom.var = c("point", "text"),pointshape = 19)

```

General quality of representation of the variables in the chosen model


```{r}
corrplot(pc1$var$cos2[,1:6],is.corr=FALSE,number.cex = 0.5,tl.col="gray31",tl.cex=0.5,
	   cl.ratio=0.25,cl.cex=0.5, cl.align="l",mar=c(0,0,1.5,0),title="Variable representation",cex.main=0.7)

corrplot(pc1$var$cor[,1:4],cex.main=0.7,method = c("square"),number.cex = 0.5,tl.cex=0.7,tl.col="gray31",cl.align="c",tl.offset = 0.1)
```
The previous diagram represents in a comparative way the quality of the representation of each of the analysis variables in each of the six factors of the principal components model, the intensity of the color and the size of the circles is related to the percentage of inertia of the variable that was retained by the factor, in this way and in the first measure, each of the variables can be associated with the different latent factors of the model that are explaining them.



```{r}
x1 <- t(cumsum(as.data.frame(t(pc1$var$cos2[,1:4]))))
x1 <- as.data.frame(x1[order(-x1[,4]),])
x1$variable <- factor(rownames(x1), levels=rownames(x1)[order(-x1$Dim.4)] )


#barplot(x,las=2,cex.lab=0.5)

p <- ggplot(data=x1, aes(x=variable, y=Dim.4)) +
  geom_bar(stat="identity", fill="#E7B800") +
  scale_y_continuous(labels = scales::percent) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    axis.title.x= element_blank()) + labs(title = "Quality of representation of the variables in the chosen PCA", y = "Quality")
p
```

The previous summary shows the quality of the representation of the variables in the chosen six-factor model, these percentages are based on the quality statistics of representation by factor shown in the circle diagram. they have less linear relationship with the general set of variables.

Quality per component

```{r, size ='tiny'}
listpl<-list()
for (i in 1:4){
                tmpnm<-paste("varcontComp",i,sep="")
                assign(tmpnm,fviz_contrib(pc1, choice = "var", axes = i, top = 14, fill = "#E7B800", color = "#E7B800",font.tickslab = c(7), xtickslab.rt=90)+labs(title = paste("Contribution component",i), x = "", y = ""))
		    listpl[[tmpnm]] <- get(tmpnm)
              }
do.call(grid.arrange, listpl)
```

```{r}
cont1 <- pc1$var$contrib[order(-pc1$var$contrib[,1]),1]
cont1 <- cont1[cont1>(100/29)]
print("Componente 1")
print(cont1,digits = 2)

cont2 <- pc1$var$contrib[order(-pc1$var$contrib[,2]),2]
cont2 <- cont2[cont2>(100/29)]
print("Componente 2")
print(cont2,digits = 2)

cont3 <- pc1$var$contrib[order(-pc1$var$contrib[,3]),3]
cont3 <- cont3[cont3>(100/29)]
print("Componente 3")
print(cont3,digits = 2)

cont4 <- pc1$var$contrib[order(-pc1$var$contrib[,4]),4]
cont4 <- cont4[cont4>(100/29)]
print("Componente 4")
print(cont4,digits = 2)

```

Los anteriores son los porcentajes de contribuci?n a la inercia del componente con una inercia superior a la contribuci?n promedio por variable.

C?rculos de correlaciones de todos los planos
```{r, size ='tiny'}
## Circulos de correlaciones
listplan<-list()
m <- combn(1:4, 2)
colnames(m) <- letters[1:6]
colscor2=c("#00AFBB", "#E7B800", "#FC4E07")
for(i in 1:length(colnames(m))){
tmp<-m[,i]
nm<-paste0("plan",i)
assign(nm,
fviz_pca_var(pc1,axes = tmp,col.var="cos2",geom=c("point","text"),gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),repel=TRUE,labelsize = 3))
listplan[[nm]] <- get(nm)
print(listplan[[nm]])
}

```

